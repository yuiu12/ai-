'''
第一步： 首先分析赢的条件，假设每次可以报4个数，要想抢到56，则自己上次报的数以满足以下条件：①、与56的距离大于四，②、不管对手报的是几，自己都能报到56。而对手报的最小数字是一，所以自己上次报的数必须与56的距离为5
第二步： 将4换成m，那么自己只要保证每次与对手报的数和为m+1便可胜利
第三步： 由于自己先报，又要保证之后每次与对手报的数和为m+1，那么只需要报的数与n的距离为m+1的倍数即可
第四步： 既然如此，那么若数n本身就是m+1的倍数，自己就一定会输
第五步： 经过以上分析，可以开始写代码了！
'''
def a(m,n):
    #判断最终数是否是最大报数加一的倍数
    if n % (m + 1) == 0:
        print('在对手不失误的情况下，你输定了')
    else:
        #不是倍数的情况下，求n除以m+1的余数
        a = n % (m + 1) 
        print(f'第一次应该报{a}') 
m,n = map(int,input('请输入单词最大报数以及最终胜利数,中间用空格隔开').split())
a(m,n)